package com.footballay.core.domain.facade

import com.footballay.core.common.result.DomainResult
import com.footballay.core.infra.persistence.apisports.entity.FixtureApiSports
import com.footballay.core.infra.persistence.apisports.entity.LeagueApiSports
import com.footballay.core.infra.persistence.apisports.entity.TeamApiSports
import com.footballay.core.infra.persistence.apisports.repository.FixtureApiSportsRepository
import com.footballay.core.infra.persistence.apisports.repository.LeagueApiSportsRepository
import com.footballay.core.infra.persistence.apisports.repository.TeamApiSportsRepository
import com.footballay.core.infra.persistence.core.entity.FixtureCore
import com.footballay.core.infra.persistence.core.entity.FixtureStatusCode
import com.footballay.core.infra.persistence.core.entity.LeagueCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.infra.persistence.core.repository.FixtureCoreRepository
import com.footballay.core.infra.persistence.core.repository.LeagueCoreRepository
import com.footballay.core.infra.persistence.core.repository.TeamCoreRepository
import com.footballay.core.logger
import jakarta.persistence.EntityManager
import jakarta.persistence.PersistenceContext
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.ZoneOffset
import java.time.temporal.ChronoUnit

/**
 * DesktopFixtureFacade 통합 테스트
 *
 * ## 테스트 범위
 * - previous 모드: 기준 날짜 이전 가장 가까운 날짜의 fixtures 조회
 * - exact 모드: 특정 날짜의 모든 fixtures 조회
 * - nearest 모드: 기준 날짜 이후 가장 가까운 날짜의 fixtures 조회
 * - Repository findMaxKickoffBeforeByLeagueUid 쿼리 검증
 */
@SpringBootTest
@ActiveProfiles("test")
@Transactional
class DesktopFixtureFacadeImplTest {
    val log = logger()

    @Autowired
    private lateinit var desktopFixtureFacade: DesktopFixtureFacade

    @Autowired
    private lateinit var fixtureCoreRepository: FixtureCoreRepository

    @Autowired
    private lateinit var fixtureApiSportsRepository: FixtureApiSportsRepository

    @Autowired
    private lateinit var leagueCoreRepository: LeagueCoreRepository

    @Autowired
    private lateinit var leagueApiSportsRepository: LeagueApiSportsRepository

    @Autowired
    private lateinit var teamCoreRepository: TeamCoreRepository

    @Autowired
    private lateinit var teamApiSportsRepository: TeamApiSportsRepository

    @PersistenceContext
    private lateinit var em: EntityManager

    private lateinit var testLeague: LeagueCore
    private lateinit var testLeagueApiSports: LeagueApiSports
    private lateinit var homeTeam: TeamCore
    private lateinit var awayTeam: TeamCore

    @BeforeEach
    fun setUp() {
        testLeague =
            LeagueCore(
                uid = "test_league_uid",
                name = "Test League",
                available = true,
                autoGenerated = false,
            )
        leagueCoreRepository.save(testLeague)

        testLeagueApiSports =
            LeagueApiSports(
                apiId = 999L,
                name = "Test League",
                type = "League",
                leagueCore = testLeague,
            )
        leagueApiSportsRepository.save(testLeagueApiSports)

        homeTeam =
            TeamCore(
                uid = "home_team_uid",
                name = "Home Team",
                autoGenerated = false,
            )
        awayTeam =
            TeamCore(
                uid = "away_team_uid",
                name = "Away Team",
                autoGenerated = false,
            )
        teamCoreRepository.saveAll(listOf(homeTeam, awayTeam))

        // TeamApiSports 생성
        val homeTeamApi =
            TeamApiSports(
                apiId = 100L,
                name = "Home Team",
                teamCore = homeTeam,
            )
        val awayTeamApi =
            TeamApiSports(
                apiId = 200L,
                name = "Away Team",
                teamCore = awayTeam,
            )
        teamApiSportsRepository.saveAll(listOf(homeTeamApi, awayTeamApi))

        em.flush()
        em.clear()
    }

    @Test
    fun `previous 모드 - 기준 날짜 이전 가장 가까운 날짜의 경기들 반환`() {
        // Given: 2025-03-03에 2개, 2025-03-05에 1개 경기
        val requestDate = Instant.parse("2025-03-05T10:00:00Z")
        val previousDate = Instant.parse("2025-03-03T10:00:00Z")

        val fixturesOnPreviousDate =
            listOf(
                createFixtureWithApiSports("f1", previousDate),
                createFixtureWithApiSports("f2", previousDate.plus(3, ChronoUnit.HOURS)),
            )
        val fixtureOnRequestDate = createFixtureWithApiSports("f3", requestDate)

        fixtureCoreRepository.saveAll(fixturesOnPreviousDate + fixtureOnRequestDate)
        em.flush()
        em.clear()

        // When
        val result =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "previous",
                ZoneOffset.UTC,
            )

        // Then
        assertThat(result).isInstanceOf(DomainResult.Success::class.java)
        val fixtures = (result as DomainResult.Success).value
        assertThat(fixtures).hasSize(2)
        assertThat(fixtures.map { it.uid }).containsExactlyInAnyOrder("f1", "f2")
        log.info("Previous mode: Found ${fixtures.size} fixtures on previous date (2025-03-03)")
    }

    @Test
    fun `previous 모드 - 이전 날짜에 경기 없으면 빈 리스트 반환`() {
        // Given: 기준일 이후에만 경기가 있음
        val requestDate = Instant.parse("2025-03-05T10:00:00Z")
        val futureFixture = createFixtureWithApiSports("f1", requestDate.plus(2, ChronoUnit.DAYS))

        fixtureCoreRepository.save(futureFixture)
        em.flush()
        em.clear()

        // When
        val result =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "previous",
                ZoneOffset.UTC,
            )

        // Then
        assertThat(result).isInstanceOf(DomainResult.Success::class.java)
        val fixtures = (result as DomainResult.Success).value
        assertThat(fixtures).isEmpty()
        log.info("Previous mode: No fixtures found before request date (expected)")
    }

    @Test
    fun `exact 모드 - 해당 날짜의 모든 fixtures 반환`() {
        // Given: 2025-03-05에 3개 경기
        val targetDate = Instant.parse("2025-03-05T10:00:00Z")

        val fixturesOnTarget =
            listOf(
                createFixtureWithApiSports("f1", targetDate),
                createFixtureWithApiSports("f2", targetDate.plus(3, ChronoUnit.HOURS)),
                createFixtureWithApiSports("f3", targetDate.plus(6, ChronoUnit.HOURS)),
            )
        val fixtureNextDay = createFixtureWithApiSports("f4", targetDate.plus(1, ChronoUnit.DAYS))

        fixtureCoreRepository.saveAll(fixturesOnTarget + fixtureNextDay)
        em.flush()
        em.clear()

        // When
        val result =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                targetDate,
                "exact",
                ZoneOffset.UTC,
            )

        // Then
        assertThat(result).isInstanceOf(DomainResult.Success::class.java)
        val fixtures = (result as DomainResult.Success).value
        assertThat(fixtures).hasSize(3)
        assertThat(fixtures.map { it.uid }).containsExactlyInAnyOrder("f1", "f2", "f3")
        log.info("Exact mode: Found ${fixtures.size} fixtures on target date")
    }

    @Test
    fun `nearest 모드 - 해당 날짜 이후 가장 가까운 날짜의 경기들 반환`() {
        // Given: 2025-03-05 요청, 03-07에 경기 있음
        val requestDate = Instant.parse("2025-03-05T10:00:00Z")
        val nearestDate = Instant.parse("2025-03-07T10:00:00Z")

        val fixturesOnNearestDate =
            listOf(
                createFixtureWithApiSports("f1", nearestDate),
                createFixtureWithApiSports("f2", nearestDate.plus(3, ChronoUnit.HOURS)),
            )
        val fartherFixture = createFixtureWithApiSports("f3", nearestDate.plus(5, ChronoUnit.DAYS))

        fixtureCoreRepository.saveAll(fixturesOnNearestDate + fartherFixture)
        em.flush()
        em.clear()

        // When
        val result =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "nearest",
                ZoneOffset.UTC,
            )

        // Then
        assertThat(result).isInstanceOf(DomainResult.Success::class.java)
        val fixtures = (result as DomainResult.Success).value
        assertThat(fixtures).hasSize(2)
        assertThat(fixtures.map { it.uid }).containsExactlyInAnyOrder("f1", "f2")
        log.info("Nearest mode: Found ${fixtures.size} fixtures on nearest date (2025-03-07)")
    }

    @Test
    fun `Repository findMaxKickoffBeforeByLeagueUid - 이전 최신 kickoff 조회`() {
        // Given
        val beforeDate = Instant.parse("2025-03-05T10:00:00Z")
        val fixture1 = createFixtureWithApiSports("f1", Instant.parse("2025-03-01T10:00:00Z"))
        val fixture2 = createFixtureWithApiSports("f2", Instant.parse("2025-03-03T15:00:00Z"))
        val fixture3 = createFixtureWithApiSports("f3", Instant.parse("2025-03-06T10:00:00Z"))

        fixtureCoreRepository.saveAll(listOf(fixture1, fixture2, fixture3))
        em.flush()
        em.clear()

        // When
        val maxKickoff = fixtureCoreRepository.findMaxKickoffBeforeByLeagueUid(testLeague.uid, beforeDate)

        // Then
        assertThat(maxKickoff).isNotNull
        assertThat(maxKickoff).isEqualTo(Instant.parse("2025-03-03T15:00:00Z"))
        log.info("findMaxKickoffBeforeByLeagueUid: Found $maxKickoff")
    }

    @Test
    fun `3가지 모드 연속 테스트 - previous, exact, nearest 동작 확인`() {
        // Given: 03-01, 03-05, 03-10에 각각 경기
        val date0301 = Instant.parse("2025-03-01T10:00:00Z")
        val date0305 = Instant.parse("2025-03-05T10:00:00Z")
        val date0310 = Instant.parse("2025-03-10T10:00:00Z")

        val fixture1 = createFixtureWithApiSports("march01", date0301)
        val fixture2 = createFixtureWithApiSports("march05", date0305)
        val fixture3 = createFixtureWithApiSports("march10", date0310)

        fixtureCoreRepository.saveAll(listOf(fixture1, fixture2, fixture3))
        em.flush()
        em.clear()

        // When & Then: 03-05 기준으로 3가지 모드 테스트
        val requestDate = date0305

        // previous: 03-01 경기
        val previousResult =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "previous",
                ZoneOffset.UTC,
            )
        assertThat((previousResult as DomainResult.Success).value.map { it.uid })
            .containsExactly("march01")

        // exact: 03-05 경기
        val exactResult =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "exact",
                ZoneOffset.UTC,
            )
        assertThat((exactResult as DomainResult.Success).value.map { it.uid })
            .containsExactly("march05")

        // nearest: 03-05 경기 (해당 날짜에 경기 있으면 그 날 반환)
        val nearestResult =
            desktopFixtureFacade.getFixturesByLeague(
                testLeague.uid,
                requestDate,
                "nearest",
                ZoneOffset.UTC,
            )
        assertThat((nearestResult as DomainResult.Success).value.map { it.uid })
            .containsExactly("march05")

        log.info("All 3 modes tested successfully")
    }

    private fun createFixtureWithApiSports(
        uid: String,
        kickoff: Instant,
    ): FixtureCore {
        val fixtureCore =
            FixtureCore(
                uid = uid,
                kickoff = kickoff,
                statusText = "Not Started",
                statusCode = FixtureStatusCode.NS,
                league = testLeague,
                homeTeam = homeTeam,
                awayTeam = awayTeam,
                goalsHome = 0,
                goalsAway = 0,
                finished = false,
                available = true,
                autoGenerated = false,
            )
        fixtureCoreRepository.save(fixtureCore)

        val fixtureApiSports =
            FixtureApiSports(
                apiId = uid.hashCode().toLong().let { if (it < 0) -it else it },
                core = fixtureCore,
                round = "Round 1",
                season = null,
            )
        fixtureApiSportsRepository.save(fixtureApiSports)

        return fixtureCore
    }
}
