package com.footballay.core.infra.apisports

import com.footballay.core.infra.apisports.dto.PlayerApiSportsCreateDto
import com.footballay.core.infra.core.util.UidGenerator
import com.footballay.core.infra.persistence.apisports.entity.PlayerApiSports
import com.footballay.core.infra.persistence.apisports.entity.TeamApiSports
import com.footballay.core.infra.persistence.apisports.repository.PlayerApiSportsRepository
import com.footballay.core.infra.persistence.apisports.repository.TeamApiSportsRepository
import com.footballay.core.infra.persistence.core.entity.PlayerCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.infra.persistence.core.entity.TeamPlayerCore
import com.footballay.core.infra.persistence.core.repository.PlayerCoreRepository
import com.footballay.core.infra.persistence.core.repository.TeamCoreRepository
import com.footballay.core.infra.persistence.core.repository.TeamPlayerCoreRepository
import com.footballay.core.logger
import jakarta.persistence.EntityManager
import jakarta.persistence.PersistenceContext
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional

@SpringBootTest
@ActiveProfiles("dev", "mocks")
@Transactional
class PlayerApiSportsSyncerIntegrationTest {

    val log = logger()

    @Autowired
    private lateinit var playerApiSportsSyncer: PlayerApiSportsSyncer

    @Autowired
    private lateinit var playerApiSportsRepository: PlayerApiSportsRepository

    @Autowired
    private lateinit var playerCoreRepository: PlayerCoreRepository

    @Autowired
    private lateinit var teamCoreRepository: TeamCoreRepository

    @Autowired
    private lateinit var teamPlayerCoreRepository: TeamPlayerCoreRepository

    @Autowired
    private lateinit var teamApiSportsRepository: TeamApiSportsRepository

    @Autowired
    private lateinit var uidGenerator: UidGenerator

    @PersistenceContext
    private lateinit var em: EntityManager

    private lateinit var testTeamCore: TeamCore
    private lateinit var testTeamApi: TeamApiSports

    @BeforeEach
    fun setUp() {
        createTestTeam()
    }

    /**
     * 통합 테스트 1: 팀에 새로운 선수들을 추가하고 연관관계가 정상적으로 설정되는지 검증
     */
    @Test
    fun `팀에 새로운 선수들을 추가하면 연관관계가 정상적으로 설정되어야 한다`() {
        // Given
        val playerDtos = listOf(
            createPlayerDto(101L, "Son Heung-min", "Forward"),
            createPlayerDto(102L, "Harry Kane", "Forward")
        )
        log.info(playerDtos.toString())

        // When
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, playerDtos)
        flushAndClear()

        // Then
        // 1. PlayerApiSports 엔티티 확인
        val savedPlayers = playerApiSportsRepository.findAllByApiIdIn(listOf(101L, 102L))
        assertEquals(2, savedPlayers.size)

        // 2. PlayerCore 엔티티 확인 (PlayerApiSports를 통해 확인)
        val playerApiSports = playerApiSportsRepository.findAllByApiIdIn(listOf(101L, 102L))
        val playerCores = playerApiSports.mapNotNull { it.playerCore }
        assertEquals(2, playerCores.size)

        // 3. TeamCore-PlayerCore 연관관계 확인 (Repository를 통한 직접 조회)
        val teamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        assertEquals(2, teamPlayerRelations.size)
        
        val playersInTeam = teamPlayerRelations.mapNotNull { it.player }
        val playerNames = playersInTeam.map { it.name }
        assertTrue(playerNames.contains("Son Heung-min"))
        assertTrue(playerNames.contains("Harry Kane"))
    }

    /**
     * 통합 테스트 2: 기존 선수를 업데이트하고 새 선수를 추가하는 경우 모두 정상 처리되는지 검증
     */
    @Test
    fun `기존 선수를 업데이트하고 새 선수를 추가하는 경우 모두 정상 처리되어야 한다`() {
        // Given
        // 기존 선수 생성
        val playerUid = uidGenerator.generateUid()

        val existingPlayerCore = PlayerCore(
            uid = playerUid,
            name = "Son Heung-min (Old)",
            autoGenerated = true
        )
        val savedPlayerCore = playerCoreRepository.save(existingPlayerCore)
        
        // 명시적으로 연관관계 생성
        val teamPlayerCore = TeamPlayerCore(
            team = testTeamCore,
            player = savedPlayerCore
        )
        teamPlayerCoreRepository.save(teamPlayerCore)

        // PlayerApiSports 생성
        val existingPlayerApiSports = PlayerApiSports(
            playerCore = savedPlayerCore,
            apiId = 101L,
            name = "Son Heung-min (Old)",
            position = "Forward"
        )
        playerApiSportsRepository.save(existingPlayerApiSports)

        // 업데이트할 DTO 목록 (기존 선수 업데이트 + 새 선수 추가)
        val playerDtos = listOf(
            createPlayerDto(101L, "Son Heung-min (Updated)", "Forward"), // 업데이트
            createPlayerDto(102L, "Harry Kane", "Forward") // 새로 추가
        )

        // When
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, playerDtos)
        flushAndClear()

        // Then
        // 1. 업데이트된 PlayerApiSports 확인
        val updatedPlayer = playerApiSportsRepository.findPlayerApiSportsByApiIdWithPlayerCore(101L)
        assertNotNull(updatedPlayer)
        assertEquals("Son Heung-min (Updated)", updatedPlayer?.name)

        // 2. 새로 추가된 선수 확인
        val newPlayer = playerApiSportsRepository.findPlayerApiSportsByApiIdWithPlayerCore(102L)
        assertNotNull(newPlayer)
        assertEquals("Harry Kane", newPlayer?.name)

        // 3. TeamCore-PlayerCore 연관관계 확인
        val teamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        assertEquals(2, teamPlayerRelations.size)
    }

    /**
     * 통합 테스트 3: PlayerApiSports 엔티티는 존재하지만 PlayerCore가 없는 비정상 케이스 처리 검증
     */
    @Test
    fun `PlayerApiSports만 존재하고 PlayerCore가 없는 경우 자동으로 생성되어야 한다`() {
        // Given
        // PlayerCore 없는 PlayerApiSports 생성
        val playerApiSportsWithoutCore = PlayerApiSports(
            playerCore = null,
            apiId = 101L,
            name = "Son Heung-min",
            position = "Forward"
        )
        playerApiSportsRepository.save(playerApiSportsWithoutCore)
        flushAndClear()

        val playerDtos = listOf(
            createPlayerDto(101L, "Son Heung-min", "Forward")
        )

        // When
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, playerDtos)
        flushAndClear()

        // Then
        val updatedPlayer = playerApiSportsRepository.findPlayerApiSportsByApiIdWithPlayerCore(101L)
        assertNotNull(updatedPlayer?.playerCore)
        assertEquals("Son Heung-min", updatedPlayer?.playerCore?.name)

        // TeamCore-PlayerCore 연관관계 확인
        val teamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        assertEquals(1, teamPlayerRelations.size)
    }

    /**
     * 통합 테스트 4: 반복적인 업데이트 후에도 팀에 속한 선수 목록이 정확하게 유지되는지 검증
     * (선수가 DTO에 없어도 기존 연관관계는 유지되는 정책)
     */
    @Test
    fun `반복적인 업데이트 후에도 기존 선수 연관관계가 유지되어야 한다`() {
        // Given - 초기 선수 3명 생성
        val initialPlayers = listOf(
            createPlayerDto(101L, "Son Heung-min", "Forward"),
            createPlayerDto(102L, "Harry Kane", "Forward"),
            createPlayerDto(103L, "Dele Alli", "Midfielder")
        )
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, initialPlayers)

        // 초기 상태 확인
        val initialTeamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        assertEquals(3, initialTeamPlayerRelations.size)

        // When - 일부 선수만 포함된 DTO로 업데이트 (101, 102만 포함, 103은 제외)
        val updatedPlayers = listOf(
            createPlayerDto(101L, "Son Heung-min", "Forward"),
            createPlayerDto(102L, "Harry Kane", "Forward")
        )
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, updatedPlayers)
        flushAndClear()

        // Then - 모든 선수가 여전히 팀에 속해 있어야 함 (정책에 따라)
        val finalTeamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        val finalPlayersInTeam = finalTeamPlayerRelations.mapNotNull { it.player }
        assertEquals(3, finalPlayersInTeam.size)

        // 모든 선수가 여전히 존재하는지 확인 (이름으로 확인)
        val playerNames = finalPlayersInTeam.map { it.name }
        assertTrue(playerNames.contains("Son Heung-min"))
        assertTrue(playerNames.contains("Harry Kane"))
        assertTrue(playerNames.contains("Dele Alli"))
    }

    /**
     * 통합 테스트 5: 새로운 선수 추가 시 중복 연관관계가 생성되지 않는지 검증
     */
    @Test
    fun `동일한 선수를 반복 추가해도 중복 연관관계가 생성되지 않아야 한다`() {
        // Given
        val playerDto = createPlayerDto(101L, "Son Heung-min", "Forward")

        // When - 같은 선수를 두 번 추가
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, listOf(playerDto))
        flushAndClear()
        
        playerApiSportsSyncer.syncPlayersOfTeam(testTeamApi.apiId!!, listOf(playerDto))
        flushAndClear()

        // Then - 연관관계는 하나만 존재해야 함
        val teamPlayerRelations = teamPlayerCoreRepository.findByTeamId(testTeamCore.id!!)
        assertEquals(1, teamPlayerRelations.size)
        
        val playersInTeam = teamPlayerRelations.mapNotNull { it.player }
        assertEquals(1, playersInTeam.size)
        assertEquals("Son Heung-min", playersInTeam[0].name)
    }

    /**
     * 통합 테스트 6: 존재하지 않는 팀 ID로 호출 시 예외가 발생하는지 검증
     */
    @Test
    fun `존재하지 않는 팀 ID로 호출 시 예외가 발생해야 한다`() {
        // Given
        val nonExistentTeamId = 9999L
        val playerDtos = listOf(createPlayerDto(101L, "Son Heung-min", "Forward"))

        // Then
        assertThrows(IllegalArgumentException::class.java) {
            // When
            playerApiSportsSyncer.syncPlayersOfTeam(nonExistentTeamId, playerDtos)
        }
    }

    /**
     * 테스트 데이터 생성 헬퍼 메서드
     */
    private fun createTestTeam() {
        // TeamCore 생성
        val teamUid = uidGenerator.generateUid()
        log.info("teamUid 생성 확인: $teamUid")

        // UID 유효성 확인
        if (!uidGenerator.isValidUid(teamUid)) {
            throw IllegalStateException("생성된 팀 UID가 유효하지 않습니다: $teamUid")
        }

        testTeamCore = TeamCore(
            uid = teamUid,
            name = "Tottenham Hotspur",
            available = true,
            autoGenerated = false
        )
        testTeamCore = teamCoreRepository.save(testTeamCore)

        testTeamApi = TeamApiSports(
            teamCore = testTeamCore,
            apiId = 123L,
            name = "Tottenham Hotspur",
            code = "TOT",
            country = "England",
            founded = 1882,
            national = false
        )
        testTeamApi = teamApiSportsRepository.save(testTeamApi);

        flushAndClear()
//        testTeamCore = em.merge(testTeamCore)
//        testTeamApi = em.merge(testTeamApi)
    }

    private fun createPlayerDto(
        apiId: Long,
        name: String,
        position: String,
        age: Int? = 25,
        nationality: String? = "South Korea"
    ): PlayerApiSportsCreateDto {
        return PlayerApiSportsCreateDto(
            apiId = apiId,
            name = name,
            position = position,
            age = age,
            nationality = nationality,
            firstname = name.split(" ").firstOrNull(),
            lastname = name.split(" ").drop(1).joinToString(" ").takeIf { it.isNotEmpty() }
        )
    }

    private inline fun flushAndClear() {
        em.flush()
        em.clear()
    }
} 