package com.footballay.core.infra.persistence.core.repository

import com.footballay.core.infra.persistence.core.entity.FixtureCore
import com.footballay.core.infra.persistence.core.entity.FixtureStatusShort
import com.footballay.core.infra.persistence.core.entity.LeagueCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.logger
import jakarta.persistence.EntityManager
import jakarta.persistence.PersistenceContext
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * FixtureCoreRepository 단위 테스트
 *
 * ## 테스트 목적
 * - 각 Repository 메서드의 쿼리가 올바르게 동작하는지 검증
 * - 비즈니스 로직 조합은 Service 레이어에서 테스트
 *
 * @author Footballay Core Team
 */
@SpringBootTest
@ActiveProfiles("dev", "mockapi")
@Transactional
class FixtureCoreRepositoryTest {
    val log = logger()

    @Autowired
    private lateinit var fixtureCoreRepository: FixtureCoreRepository

    @Autowired
    private lateinit var leagueCoreRepository: LeagueCoreRepository

    @Autowired
    private lateinit var teamCoreRepository: TeamCoreRepository

    @PersistenceContext
    private lateinit var em: EntityManager

    private lateinit var testLeague: LeagueCore
    private lateinit var homeTeam: TeamCore
    private lateinit var awayTeam: TeamCore

    @BeforeEach
    fun setUp() {
        testLeague =
            LeagueCore(
                uid = "test_league_repo",
                name = "Test League Repository",
                available = true,
                autoGenerated = false,
            )
        leagueCoreRepository.save(testLeague)

        homeTeam =
            TeamCore(
                uid = "home_team_repo",
                name = "Home Team Repo",
                autoGenerated = false,
            )
        awayTeam =
            TeamCore(
                uid = "away_team_repo",
                name = "Away Team Repo",
                autoGenerated = false,
            )
        teamCoreRepository.saveAll(listOf(homeTeam, awayTeam))

        em.flush()
        em.clear()
    }

    @Test
    fun `범위 내 fixtures만 조회 - findFixturesInKickoffRange`() {
        // Given
        val start = Instant.parse("2025-03-05T00:00:00Z")
        val end = Instant.parse("2025-03-06T00:00:00Z")

        val fixturesInRange =
            listOf(
                createFixture("in1", start.plus(2, ChronoUnit.HOURS)),
                createFixture("in2", start.plus(12, ChronoUnit.HOURS)),
            )

        val fixtureOutOfRange = createFixture("out", end.plus(1, ChronoUnit.HOURS))

        fixtureCoreRepository.saveAll(fixturesInRange + fixtureOutOfRange)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findFixturesInKickoffRange(testLeague.id!!, start, end)

        // Then
        assertThat(result).hasSize(2)
        assertThat(result.map { it.uid }).containsExactly("in1", "in2")
    }

    @Test
    fun `시간 범위에서 end 는 Exclusive - findFixturesInKickoffRange`() {
        // Given
        val start = Instant.parse("2025-03-05T10:00:00Z")
        val end = Instant.parse("2025-03-05T20:00:00Z") // end Exclusive

        val fixturesIn =
            listOf(
                createFixture("at_start", start), // startInclusive
                createFixture("in_range", start.plus(1, ChronoUnit.HOURS)), // 범위 내
            )
        val fixturesEx =
            listOf(
                createFixture("at_end", end), // endExclusive - 제외되어야 함
            )

        fixtureCoreRepository.saveAll(fixturesIn + fixturesEx)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findFixturesInKickoffRange(testLeague.id!!, start, end)

        // Then
        assertThat(result).hasSize(2)
        assertThat(result.map { it.uid }).containsExactly("at_start", "in_range")
    }

    @Test
    fun `kickoff 오름차순 정렬 - findFixturesInKickoffRange`() {
        // Given
        val start = Instant.parse("2025-03-05T00:00:00Z")
        val end = Instant.parse("2025-03-06T00:00:00Z")

        val fixtures =
            listOf(
                createFixture("f3", start.plus(20, ChronoUnit.HOURS)),
                createFixture("f1", start.plus(5, ChronoUnit.HOURS)),
                createFixture("f2", start.plus(12, ChronoUnit.HOURS)),
            )

        fixtureCoreRepository.saveAll(fixtures)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findFixturesInKickoffRange(testLeague.id!!, start, end)

        // Then
        assertThat(result.map { it.uid }).containsExactly("f1", "f2", "f3")
    }

    @Test
    fun `다른 리그는 제외 - findFixturesInKickoffRange`() {
        // Given
        val otherLeague =
            LeagueCore(
                uid = "other_league",
                name = "Other League",
                available = true,
                autoGenerated = false,
            )
        leagueCoreRepository.save(otherLeague)

        val start = Instant.parse("2025-03-05T00:00:00Z")
        val end = Instant.parse("2025-03-06T00:00:00Z")
        val kickoff = start.plus(10, ChronoUnit.HOURS)

        val testLeagueFixture =
            createFixture("test_league_fixture", kickoff)
        val otherLeagueFixture =
            createFixture(
                "other_league_fixture",
                kickoff,
                league = otherLeague,
            )

        fixtureCoreRepository.saveAll(listOf(testLeagueFixture, otherLeagueFixture))
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findFixturesInKickoffRange(testLeague.id!!, start, end)

        // Then
        assertThat(result).hasSize(1)
        assertThat(result[0].uid).isEqualTo("test_league_fixture")
    }

    @Test
    fun `빈 범위면 빈 리스트 반환 - findFixturesInKickoffRange`() {
        // Given
        val start = Instant.parse("2025-03-05T00:00:00Z")
        val end = Instant.parse("2025-03-06T00:00:00Z")

        val pastFixture = createFixture("past", start.minus(10, ChronoUnit.DAYS))
        val futureFixture = createFixture("future", end.plus(10, ChronoUnit.DAYS))

        fixtureCoreRepository.saveAll(listOf(pastFixture, futureFixture))
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findFixturesInKickoffRange(testLeague.id!!, start, end)

        // Then
        assertThat(result).isEmpty()
    }

    @Test
    fun `가장 가까운 kickoff 시각 반환 - findMinKickoffAfter`() {
        // Given
        val from = Instant.parse("2025-03-05T10:00:00Z")

        val fixtures =
            listOf(
                createFixture("f1", from.plus(10, ChronoUnit.DAYS)), // 가장 먼 미래
                createFixture("f2", from.plus(2, ChronoUnit.DAYS)), // 가장 가까운 미래
                createFixture("f3", from.plus(5, ChronoUnit.DAYS)),
            )

        fixtureCoreRepository.saveAll(fixtures)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findMinKickoffAfter(testLeague.id!!, from)

        // Then
        assertThat(result).isEqualTo(from.plus(2, ChronoUnit.DAYS))
    }

    @Test
    fun `from과 같은 시각도 포함 (Inclusive) - findMinKickoffAfter`() {
        // Given
        val exactTime = Instant.parse("2025-03-05T15:30:00Z")
        val fixture = createFixture("exact", exactTime)
        fixtureCoreRepository.save(fixture)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findMinKickoffAfter(testLeague.id!!, exactTime)

        // Then
        assertThat(result).isEqualTo(exactTime)
    }

    @Test
    fun `과거 경기는 제외 - findMinKickoffAfter`() {
        // Given
        val from = Instant.parse("2025-03-10T10:00:00Z")

        val fixtures =
            listOf(
                createFixture("past1", from.minus(5, ChronoUnit.DAYS)),
                createFixture("past2", from.minus(1, ChronoUnit.DAYS)),
                createFixture("future", from.plus(1, ChronoUnit.DAYS)),
            )

        fixtureCoreRepository.saveAll(fixtures)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findMinKickoffAfter(testLeague.id!!, from)

        // Then
        assertThat(result).isEqualTo(from.plus(1, ChronoUnit.DAYS))
    }

    @Test
    fun `미래 경기 없으면 null 반환 - findMinKickoffAfter`() {
        // Given
        val from = Instant.parse("2025-03-10T10:00:00Z")
        val pastFixture = createFixture("past", from.minus(5, ChronoUnit.DAYS))

        fixtureCoreRepository.save(pastFixture)
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findMinKickoffAfter(testLeague.id!!, from)

        // Then
        assertThat(result).isNull()
    }

    @Test
    fun `다른 리그는 제외 - findMinKickoffAfter`() {
        // Given
        val otherLeague =
            LeagueCore(
                uid = "other_league",
                name = "Other League",
                available = true,
                autoGenerated = false,
            )
        leagueCoreRepository.save(otherLeague)

        val from = Instant.parse("2025-03-05T10:00:00Z")
        val nearDate = from.plus(2, ChronoUnit.DAYS)
        val farDate = from.plus(5, ChronoUnit.DAYS)

        val testLeagueFixture = createFixture("test", farDate)
        val otherLeagueFixture =
            createFixture(
                "other",
                nearDate,
                league = otherLeague,
            )

        fixtureCoreRepository.saveAll(listOf(testLeagueFixture, otherLeagueFixture))
        em.flush()
        em.clear()

        // When
        val result = fixtureCoreRepository.findMinKickoffAfter(testLeague.id!!, from)

        // Then: 다른 리그의 더 가까운 경기는 무시
        assertThat(result).isEqualTo(farDate)
    }

    private fun createFixture(
        uid: String,
        kickoff: Instant,
        league: LeagueCore = testLeague,
    ): FixtureCore =
        FixtureCore(
            uid = uid,
            kickoff = kickoff,
            status = "Not Started",
            statusShort = FixtureStatusShort.NS,
            league = league,
            homeTeam = homeTeam,
            awayTeam = awayTeam,
            goalsHome = 0,
            goalsAway = 0,
            finished = false,
            available = true,
            autoGenerated = false,
        )
}
