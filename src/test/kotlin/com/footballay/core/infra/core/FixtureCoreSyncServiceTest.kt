package com.footballay.core.infra.core

import com.footballay.core.infra.core.dto.FixtureCoreCreateDto
import com.footballay.core.infra.core.dto.FixtureCoreUpdateDto
import com.footballay.core.infra.persistence.core.entity.FixtureCore
import com.footballay.core.infra.persistence.core.entity.FixtureStatusShort
import com.footballay.core.infra.persistence.core.entity.LeagueCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.infra.persistence.core.repository.FixtureCoreRepository
import com.footballay.core.infra.util.UidGenerator
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.any
import org.mockito.kotlin.whenever
import java.time.OffsetDateTime
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@ExtendWith(MockitoExtension::class)
class FixtureCoreSyncServiceTest {

    @Mock
    private lateinit var fixtureCoreRepository: FixtureCoreRepository

    @Mock
    private lateinit var uidGenerator: UidGenerator

    @InjectMocks
    private lateinit var fixtureCoreSyncService: FixtureCoreSyncServiceImpl

    private lateinit var leagueCore: LeagueCore
    private lateinit var homeTeamCore: TeamCore
    private lateinit var awayTeamCore: TeamCore

    @BeforeEach
    fun setUp() {
        leagueCore = LeagueCore(
            uid = "league-uid",
            name = "Test League"
        )

        homeTeamCore = TeamCore(
            uid = "home-team-uid",
            name = "Home Team",
            code = "HT",
            country = "Test Country",
            founded = 1900,
            national = false
        )

        awayTeamCore = TeamCore(
            uid = "away-team-uid",
            name = "Away Team",
            code = "AT",
            country = "Test Country",
            founded = 1900,
            national = false
        )
    }

    @Test
    fun `createFixtureCores should create multiple fixture cores and return map`() {
        // given
        val uid1 = "fixture-uid-1"
        val uid2 = "fixture-uid-2"
        
        val createDto1 = FixtureCoreCreateDto(
            uid = uid1,
            kickoff = OffsetDateTime.now(),
            timestamp = 1234567890L,
            status = "Match Finished",
            statusShort = FixtureStatusShort.FT,
            elapsedMin = 90,
            goalsHome = 2,
            goalsAway = 1,
            leagueCore = leagueCore,
            homeTeam = homeTeamCore,
            awayTeam = awayTeamCore,
            finished = true,
            available = true,
            autoGenerated = false
        )

        val createDto2 = FixtureCoreCreateDto(
            uid = uid2,
            kickoff = OffsetDateTime.now().plusDays(1),
            timestamp = 1234567891L,
            status = "Not Started",
            statusShort = FixtureStatusShort.NS,
            elapsedMin = null,
            goalsHome = null,
            goalsAway = null,
            leagueCore = leagueCore,
            homeTeam = homeTeamCore,
            awayTeam = awayTeamCore,
            finished = false,
            available = false,
            autoGenerated = true
        )

        val createPairs = listOf(
            uid1 to createDto1,
            uid2 to createDto2
        )

        val expectedFixtureCore1 = FixtureCore(
            uid = uid1,
            kickoff = createDto1.kickoff!!,
            timestamp = createDto1.timestamp!!,
            status = createDto1.status!!,
            statusShort = createDto1.statusShort!!,
            elapsedMin = createDto1.elapsedMin,
            league = createDto1.leagueCore,
            homeTeam = createDto1.homeTeam,
            awayTeam = createDto1.awayTeam,
            goalsHome = createDto1.goalsHome,
            goalsAway = createDto1.goalsAway,
            finished = createDto1.finished,
            available = createDto1.available,
            autoGenerated = createDto1.autoGenerated
        )

        val expectedFixtureCore2 = FixtureCore(
            uid = uid2,
            kickoff = createDto2.kickoff!!,
            timestamp = createDto2.timestamp!!,
            status = createDto2.status!!,
            statusShort = createDto2.statusShort!!,
            elapsedMin = createDto2.elapsedMin,
            league = createDto2.leagueCore,
            homeTeam = createDto2.homeTeam,
            awayTeam = createDto2.awayTeam,
            goalsHome = createDto2.goalsHome,
            goalsAway = createDto2.goalsAway,
            finished = createDto2.finished,
            available = createDto2.available,
            autoGenerated = createDto2.autoGenerated
        )

        whenever(fixtureCoreRepository.saveAll(any<List<FixtureCore>>())).thenReturn(listOf(expectedFixtureCore1, expectedFixtureCore2))

        // when
        val result = fixtureCoreSyncService.createFixtureCores(createPairs)

        // then
        assertEquals(2, result.size)
        assertNotNull(result[uid1])
        assertNotNull(result[uid2])
        assertEquals(expectedFixtureCore1, result[uid1])
        assertEquals(expectedFixtureCore2, result[uid2])
    }

    @Test
    fun `createFixtureCores should return empty map when input is empty`() {
        // given
        val createPairs = emptyList<Pair<String, FixtureCoreCreateDto>>()

        // when
        val result = fixtureCoreSyncService.createFixtureCores(createPairs)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `updateFixtureCores should update multiple fixture cores and return map`() {
        // given
        val uid1 = "fixture-uid-1"
        val uid2 = "fixture-uid-2"

        val existingFixtureCore1 = FixtureCore(
            uid = uid1,
            kickoff = OffsetDateTime.now(),
            timestamp = 1234567890L,
            status = "Match Finished",
            statusShort = FixtureStatusShort.FT,
            elapsedMin = 90,
            league = leagueCore,
            homeTeam = homeTeamCore,
            awayTeam = awayTeamCore,
            goalsHome = 2,
            goalsAway = 1,
            finished = true,
            available = true,
            autoGenerated = false
        )

        val existingFixtureCore2 = FixtureCore(
            uid = uid2,
            kickoff = OffsetDateTime.now().plusDays(1),
            timestamp = 1234567891L,
            status = "Not Started",
            statusShort = FixtureStatusShort.NS,
            elapsedMin = null,
            league = leagueCore,
            homeTeam = homeTeamCore,
            awayTeam = awayTeamCore,
            goalsHome = null,
            goalsAway = null,
            finished = false,
            available = false,
            autoGenerated = true
        )

        val updateDto1 = FixtureCoreUpdateDto(
            kickoff = OffsetDateTime.now().plusHours(1),
            timestamp = 1234567892L,
            status = "Match Finished",
            statusShort = FixtureStatusShort.FT,
            elapsedMin = 90,
            goalsHome = 3,
            goalsAway = 2,
            finished = true,
            available = true
        )

        val updateDto2 = FixtureCoreUpdateDto(
            kickoff = OffsetDateTime.now().plusDays(1).plusHours(1),
            timestamp = 1234567893L,
            status = "First Half",
            statusShort = FixtureStatusShort.FIRST_HALF,
            elapsedMin = 45,
            goalsHome = 1,
            goalsAway = 0,
            finished = false,
            available = true
        )

        val updatePairs = listOf(
            existingFixtureCore1 to updateDto1,
            existingFixtureCore2 to updateDto2
        )

        val expectedUpdatedFixtureCore1 = existingFixtureCore1.copy(
            kickoff = updateDto1.kickoff!!,
            timestamp = updateDto1.timestamp!!,
            status = updateDto1.status!!,
            statusShort = updateDto1.statusShort!!,
            elapsedMin = updateDto1.elapsedMin,
            goalsHome = updateDto1.goalsHome,
            goalsAway = updateDto1.goalsAway,
            finished = updateDto1.finished!!,
            available = updateDto1.available!!
        )

        val expectedUpdatedFixtureCore2 = existingFixtureCore2.copy(
            kickoff = updateDto2.kickoff!!,
            timestamp = updateDto2.timestamp!!,
            status = updateDto2.status!!,
            statusShort = updateDto2.statusShort!!,
            elapsedMin = updateDto2.elapsedMin,
            goalsHome = updateDto2.goalsHome,
            goalsAway = updateDto2.goalsAway,
            finished = updateDto2.finished!!,
            available = updateDto2.available!!
        )

        whenever(fixtureCoreRepository.saveAll(any<List<FixtureCore>>())).thenReturn(listOf(expectedUpdatedFixtureCore1, expectedUpdatedFixtureCore2))

        // when
        val result = fixtureCoreSyncService.updateFixtureCores(updatePairs)

        // then
        assertEquals(2, result.size)
        assertNotNull(result[uid1])
        assertNotNull(result[uid2])
        assertEquals(expectedUpdatedFixtureCore1, result[uid1])
        assertEquals(expectedUpdatedFixtureCore2, result[uid2])
    }

    @Test
    fun `updateFixtureCores should return empty map when input is empty`() {
        // given
        val updatePairs = emptyList<Pair<FixtureCore, FixtureCoreUpdateDto>>()

        // when
        val result = fixtureCoreSyncService.updateFixtureCores(updatePairs)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `generateUidPairs should generate UID for each request and return pairs`() {
        // given
        val requests = listOf("request1", "request2", "request3")
        val expectedUids = listOf("uid1", "uid2", "uid3")
        
        whenever(uidGenerator.generateUid())
            .thenReturn("uid1")
            .thenReturn("uid2")
            .thenReturn("uid3")

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertEquals(3, result.size)
        assertEquals("uid1" to "request1", result[0])
        assertEquals("uid2" to "request2", result[1])
        assertEquals("uid3" to "request3", result[2])
    }

    @Test
    fun `generateUidPairs should return empty list when input is empty`() {
        // given
        val requests = emptyList<String>()

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `generateUidPairs should work with different types using generics`() {
        // given
        data class TestDto(val id: Long, val name: String)
        val requests = listOf(
            TestDto(1L, "test1"),
            TestDto(2L, "test2")
        )
        
        whenever(uidGenerator.generateUid())
            .thenReturn("uid-test-1")
            .thenReturn("uid-test-2")

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertEquals(2, result.size)
        assertEquals("uid-test-1", result[0].first)
        assertEquals(TestDto(1L, "test1"), result[0].second)
        assertEquals("uid-test-2", result[1].first)
        assertEquals(TestDto(2L, "test2"), result[1].second)
    }
} 