package com.footballay.core.infra.core

import com.footballay.core.infra.core.dto.FixtureCoreCreateDto
import com.footballay.core.infra.core.dto.FixtureCoreUpdateDto
import com.footballay.core.infra.persistence.core.entity.FixtureCore
import com.footballay.core.infra.persistence.core.entity.FixtureStatusShort
import com.footballay.core.infra.persistence.core.entity.LeagueCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.infra.persistence.core.repository.FixtureCoreRepository
import com.footballay.core.infra.util.UidGenerator
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.any
import org.mockito.kotlin.whenever
import java.time.OffsetDateTime
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@ExtendWith(MockitoExtension::class)
class FixtureCoreSyncServiceTest {
    @Mock
    private lateinit var fixtureCoreRepository: FixtureCoreRepository

    @Mock
    private lateinit var uidGenerator: UidGenerator

    @InjectMocks
    private lateinit var fixtureCoreSyncService: FixtureCoreSyncServiceImpl

    private lateinit var leagueCore: LeagueCore
    private lateinit var homeTeamCore: TeamCore
    private lateinit var awayTeamCore: TeamCore

    @BeforeEach
    fun setUp() {
        leagueCore =
            LeagueCore(
                uid = "league-uid",
                name = "Test League",
            )

        homeTeamCore =
            TeamCore(
                uid = "home-team-uid",
                name = "Home Team",
                code = "HT",
                country = "Test Country",
                founded = 1900,
                national = false,
            )

        awayTeamCore =
            TeamCore(
                uid = "away-team-uid",
                name = "Away Team",
                code = "AT",
                country = "Test Country",
                founded = 1900,
                national = false,
            )
    }

    @Test
    fun `createFixtureCores should create multiple fixture cores and return map`() {
        // given
        val uid1 = "fixture-uid-1"
        val uid2 = "fixture-uid-2"

        val createDto1 =
            FixtureCoreCreateDto(
                uid = uid1,
                kickoff = OffsetDateTime.now(),
                timestamp = 1234567890L,
                status = "Match Finished",
                statusShort = FixtureStatusShort.FT,
                elapsedMin = 90,
                goalsHome = 2,
                goalsAway = 1,
                leagueCore = leagueCore,
                homeTeam = homeTeamCore,
                awayTeam = awayTeamCore,
                finished = true,
                available = true,
                autoGenerated = false,
            )

        val createDto2 =
            FixtureCoreCreateDto(
                uid = uid2,
                kickoff = OffsetDateTime.now().plusDays(1),
                timestamp = 1234567891L,
                status = "Not Started",
                statusShort = FixtureStatusShort.NS,
                elapsedMin = null,
                goalsHome = null,
                goalsAway = null,
                leagueCore = leagueCore,
                homeTeam = homeTeamCore,
                awayTeam = awayTeamCore,
                finished = false,
                available = false,
                autoGenerated = true,
            )

        val createPairs =
            listOf(
                uid1 to createDto1,
                uid2 to createDto2,
            )

        val expectedFixtureCore1 =
            FixtureCore(
                uid = uid1,
                kickoff = createDto1.kickoff!!,
                timestamp = createDto1.timestamp!!,
                status = createDto1.status!!,
                statusShort = createDto1.statusShort!!,
                elapsedMin = createDto1.elapsedMin,
                league = createDto1.leagueCore,
                homeTeam = createDto1.homeTeam,
                awayTeam = createDto1.awayTeam,
                goalsHome = createDto1.goalsHome,
                goalsAway = createDto1.goalsAway,
                finished = createDto1.finished,
                available = createDto1.available,
                autoGenerated = createDto1.autoGenerated,
            )

        val expectedFixtureCore2 =
            FixtureCore(
                uid = uid2,
                kickoff = createDto2.kickoff!!,
                timestamp = createDto2.timestamp!!,
                status = createDto2.status!!,
                statusShort = createDto2.statusShort!!,
                elapsedMin = createDto2.elapsedMin,
                league = createDto2.leagueCore,
                homeTeam = createDto2.homeTeam,
                awayTeam = createDto2.awayTeam,
                goalsHome = createDto2.goalsHome,
                goalsAway = createDto2.goalsAway,
                finished = createDto2.finished,
                available = createDto2.available,
                autoGenerated = createDto2.autoGenerated,
            )

        whenever(
            fixtureCoreRepository.saveAll(any<List<FixtureCore>>()),
        ).thenReturn(listOf(expectedFixtureCore1, expectedFixtureCore2))

        // when
        val result = fixtureCoreSyncService.createFixtureCores(createPairs)

        // then
        assertEquals(2, result.size)
        assertNotNull(result[uid1])
        assertNotNull(result[uid2])
        assertEquals(expectedFixtureCore1, result[uid1])
        assertEquals(expectedFixtureCore2, result[uid2])
    }

    @Test
    fun `createFixtureCores should return empty map when input is empty`() {
        // given
        val createPairs = emptyList<Pair<String, FixtureCoreCreateDto>>()

        // when
        val result = fixtureCoreSyncService.createFixtureCores(createPairs)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `updateFixtureCores should update multiple fixture cores and return map`() {
        // given
        val uid1 = "fixture-uid-1"
        val uid2 = "fixture-uid-2"

        val existingFixtureCore1 =
            FixtureCore(
                uid = uid1,
                kickoff = OffsetDateTime.now(),
                timestamp = 1234567890L,
                status = "Match Finished",
                statusShort = FixtureStatusShort.FT,
                elapsedMin = 90,
                league = leagueCore,
                homeTeam = homeTeamCore,
                awayTeam = awayTeamCore,
                goalsHome = 2,
                goalsAway = 1,
                finished = true,
                available = true,
                autoGenerated = false,
            )

        val existingFixtureCore2 =
            FixtureCore(
                uid = uid2,
                kickoff = OffsetDateTime.now().plusDays(1),
                timestamp = 1234567891L,
                status = "Not Started",
                statusShort = FixtureStatusShort.NS,
                elapsedMin = null,
                league = leagueCore,
                homeTeam = homeTeamCore,
                awayTeam = awayTeamCore,
                goalsHome = null,
                goalsAway = null,
                finished = false,
                available = false,
                autoGenerated = true,
            )

        val updateDto1 =
            FixtureCoreUpdateDto(
                kickoff = OffsetDateTime.now().plusHours(1),
                timestamp = 1234567892L,
                status = "Match Finished",
                statusShort = FixtureStatusShort.FT,
                elapsedMin = 90,
                goalsHome = 3,
                goalsAway = 2,
                finished = true,
                available = true,
            )

        val updateDto2 =
            FixtureCoreUpdateDto(
                kickoff = OffsetDateTime.now().plusDays(1).plusHours(1),
                timestamp = 1234567893L,
                status = "First Half",
                statusShort = FixtureStatusShort.FIRST_HALF,
                elapsedMin = 45,
                goalsHome = 1,
                goalsAway = 0,
                finished = false,
                available = true,
            )

        val updatePairs =
            listOf(
                existingFixtureCore1 to updateDto1,
                existingFixtureCore2 to updateDto2,
            )

        val expectedUpdatedFixtureCore1 =
            existingFixtureCore1.copy(
                kickoff = updateDto1.kickoff!!,
                timestamp = updateDto1.timestamp!!,
                status = updateDto1.status!!,
                statusShort = updateDto1.statusShort!!,
                elapsedMin = updateDto1.elapsedMin,
                goalsHome = updateDto1.goalsHome,
                goalsAway = updateDto1.goalsAway,
                finished = updateDto1.finished!!,
                available = updateDto1.available!!,
            )

        val expectedUpdatedFixtureCore2 =
            existingFixtureCore2.copy(
                kickoff = updateDto2.kickoff!!,
                timestamp = updateDto2.timestamp!!,
                status = updateDto2.status!!,
                statusShort = updateDto2.statusShort!!,
                elapsedMin = updateDto2.elapsedMin,
                goalsHome = updateDto2.goalsHome,
                goalsAway = updateDto2.goalsAway,
                finished = updateDto2.finished!!,
                available = updateDto2.available!!,
            )

        whenever(
            fixtureCoreRepository.saveAll(any<List<FixtureCore>>()),
        ).thenReturn(listOf(expectedUpdatedFixtureCore1, expectedUpdatedFixtureCore2))

        // when
        val result = fixtureCoreSyncService.updateFixtureCores(updatePairs)

        // then
        assertEquals(2, result.size)
        assertNotNull(result[uid1])
        assertNotNull(result[uid2])
        assertEquals(expectedUpdatedFixtureCore1, result[uid1])
        assertEquals(expectedUpdatedFixtureCore2, result[uid2])
    }

    @Test
    fun `updateFixtureCores should return empty map when input is empty`() {
        // given
        val updatePairs = emptyList<Pair<FixtureCore, FixtureCoreUpdateDto>>()

        // when
        val result = fixtureCoreSyncService.updateFixtureCores(updatePairs)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `generateUidPairs should generate UID for each request and return pairs`() {
        // given
        val requests = listOf("request1", "request2", "request3")
        val expectedUids = listOf("uid1", "uid2", "uid3")

        whenever(uidGenerator.generateUid())
            .thenReturn("uid1")
            .thenReturn("uid2")
            .thenReturn("uid3")

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertEquals(3, result.size)
        assertEquals("uid1" to "request1", result[0])
        assertEquals("uid2" to "request2", result[1])
        assertEquals("uid3" to "request3", result[2])
    }

    @Test
    fun `generateUidPairs should return empty list when input is empty`() {
        // given
        val requests = emptyList<String>()

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertTrue(result.isEmpty())
    }

    @Test
    fun `generateUidPairs should work with different types using generics`() {
        // given
        data class TestDto(
            val id: Long,
            val name: String,
        )
        val requests =
            listOf(
                TestDto(1L, "test1"),
                TestDto(2L, "test2"),
            )

        whenever(uidGenerator.generateUid())
            .thenReturn("uid-test-1")
            .thenReturn("uid-test-2")

        // when
        val result = fixtureCoreSyncService.generateUidPairs(requests)

        // then
        assertEquals(2, result.size)
        assertEquals("uid-test-1", result[0].first)
        assertEquals(TestDto(1L, "test1"), result[0].second)
        assertEquals("uid-test-2", result[1].first)
        assertEquals(TestDto(2L, "test2"), result[1].second)
    }
}
