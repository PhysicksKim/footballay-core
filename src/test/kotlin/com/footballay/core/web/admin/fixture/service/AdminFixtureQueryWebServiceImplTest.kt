package com.footballay.core.web.admin.fixture.service

import com.footballay.core.infra.persistence.core.entity.FixtureCore
import com.footballay.core.infra.persistence.core.entity.FixtureStatusShort
import com.footballay.core.infra.persistence.core.entity.LeagueCore
import com.footballay.core.infra.persistence.core.entity.TeamCore
import com.footballay.core.infra.persistence.core.repository.FixtureCoreRepository
import com.footballay.core.infra.persistence.core.repository.LeagueCoreRepository
import com.footballay.core.infra.persistence.core.repository.TeamCoreRepository
import com.footballay.core.logger
import jakarta.persistence.EntityManager
import jakarta.persistence.PersistenceContext
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.security.test.context.support.WithMockUser
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * AdminFixtureQueryWebService 통합 테스트
 *
 * ## 테스트 범위
 * - exact 모드: 특정 날짜의 모든 fixtures 조회
 * - nearest 모드: 가장 가까운 날짜의 모든 fixtures 조회
 * - DTO 매핑 및 관계 엔티티 로딩 검증
 *
 * @author Footballay Core Team
 */
@SpringBootTest
@ActiveProfiles("test")
@Transactional
@WithMockUser(roles = ["ADMIN"])
class AdminFixtureQueryWebServiceImplTest {
    val log = logger()

    @Autowired
    private lateinit var adminFixtureQueryWebService: AdminFixtureQueryWebService

    @Autowired
    private lateinit var fixtureCoreRepository: FixtureCoreRepository

    @Autowired
    private lateinit var leagueCoreRepository: LeagueCoreRepository

    @Autowired
    private lateinit var teamCoreRepository: TeamCoreRepository

    @PersistenceContext
    private lateinit var em: EntityManager

    private lateinit var testLeague: LeagueCore
    private lateinit var homeTeam: TeamCore
    private lateinit var awayTeam: TeamCore

    @BeforeEach
    fun setUp() {
        // 공통 테스트 데이터 생성
        testLeague =
            LeagueCore(
                uid = "test_league",
                name = "Test League",
                available = true,
                autoGenerated = false,
            )
        leagueCoreRepository.save(testLeague)

        homeTeam =
            TeamCore(
                uid = "home_team",
                name = "Home Team",
                autoGenerated = false,
            )
        awayTeam =
            TeamCore(
                uid = "away_team",
                name = "Away Team",
                autoGenerated = false,
            )
        teamCoreRepository.saveAll(listOf(homeTeam, awayTeam))

        em.flush()
        em.clear()
    }

    @Test
    fun `exact 모드 - 해당 날짜의 모든 fixtures 반환`() {
        // Given: 2025-03-05에 3개, 2025-03-06에 2개 경기
        val targetDate = Instant.parse("2025-03-05T10:00:00Z")

        val fixturesOnTarget =
            listOf(
                createFixture("f1", targetDate, "Not Started"),
                createFixture("f2", targetDate.plus(3, ChronoUnit.HOURS), "Not Started"),
                createFixture("f3", targetDate.plus(6, ChronoUnit.HOURS), "Not Started"),
            )
        val fixturesNextDay =
            listOf(
                createFixture("f4", targetDate.plus(1, ChronoUnit.DAYS), "Not Started"),
                createFixture("f5", targetDate.plus(1, ChronoUnit.DAYS).plus(3, ChronoUnit.HOURS), "Not Started"),
            )

        fixtureCoreRepository.saveAll(fixturesOnTarget + fixturesNextDay)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, targetDate, "exact")

        // Then
        assertThat(result).hasSize(3)
        assertThat(result.map { it.uid }).containsExactlyInAnyOrder("f1", "f2", "f3")
        log.info("Exact mode: Found ${result.size} fixtures on target date")
    }

    @Test
    fun `exact 모드 - at이 null이면 서버 현재 시간 기준으로 조회`() {
        // Given: 테스트를 위해 현재 시간 근처에 경기 생성
        val now = Instant.now()
        val todayFixture = createFixture("today", now, "Not Started")
        val tomorrowFixture = createFixture("tomorrow", now.plus(1, ChronoUnit.DAYS), "Not Started")

        fixtureCoreRepository.saveAll(listOf(todayFixture, tomorrowFixture))
        em.flush()
        em.clear()

        // When: at=null (서버 현재 시간)
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, null, "exact")

        // Then: 오늘 날짜의 경기만 반환
        assertThat(result).hasSize(1)
        assertThat(result[0].uid).isEqualTo("today")
        log.info("Exact mode with null 'at': Found ${result.size} fixtures for today")
    }

    @Test
    fun `exact 모드 - 해당 날짜에 경기 없으면 빈 리스트 반환`() {
        // Given: 경기가 없는 날짜
        val targetDate = Instant.parse("2025-03-05T10:00:00Z")
        val futureFixture = createFixture("f1", targetDate.plus(7, ChronoUnit.DAYS), "Not Started")

        fixtureCoreRepository.save(futureFixture)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, targetDate, "exact")

        // Then
        assertThat(result).isEmpty()
        log.info("Exact mode: No fixtures found on target date (expected)")
    }

    @Test
    fun `nearest 모드 - 해당 날짜에 경기 있으면 그날 모든 경기 반환`() {
        // Given: 2025-03-05에 2개 경기
        val targetDate = Instant.parse("2025-03-05T10:00:00Z")

        val fixturesOnTarget =
            listOf(
                createFixture("f1", targetDate, "Not Started"),
                createFixture("f2", targetDate.plus(5, ChronoUnit.HOURS), "Not Started"),
            )
        val futureFixture = createFixture("f3", targetDate.plus(3, ChronoUnit.DAYS), "Not Started")

        fixtureCoreRepository.saveAll(fixturesOnTarget + futureFixture)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, targetDate, "nearest")

        // Then
        assertThat(result).hasSize(2)
        assertThat(result.map { it.uid }).containsExactlyInAnyOrder("f1", "f2")
        log.info("Nearest mode (same day): Found ${result.size} fixtures")
    }

    @Test
    fun `nearest 모드 - 해당 날짜에 경기 없으면 가장 가까운 미래 날짜 경기 반환`() {
        // Given: 2025-03-05 요청, 03-07에 경기 있음
        val requestDate = Instant.parse("2025-03-05T10:00:00Z")
        val nearestDate = Instant.parse("2025-03-07T10:00:00Z")

        val fixturesOnNearestDate =
            listOf(
                createFixture("f1", nearestDate, "Not Started"),
                createFixture("f2", nearestDate.plus(3, ChronoUnit.HOURS), "Not Started"),
            )
        val fartherFixture = createFixture("f3", nearestDate.plus(5, ChronoUnit.DAYS), "Not Started")

        fixtureCoreRepository.saveAll(fixturesOnNearestDate + fartherFixture)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, requestDate, "nearest")

        // Then: 03-07의 모든 경기만 반환
        assertThat(result).hasSize(2)
        assertThat(result.map { it.uid }).containsExactlyInAnyOrder("f1", "f2")
        log.info("Nearest mode (future date): Found ${result.size} fixtures on nearest date (2025-03-07)")
    }

    @Test
    fun `nearest 모드 - 가장 가까운 날짜도 경기 없으면 빈 리스트 반환`() {
        // Given: 아무 경기도 없음
        val requestDate = Instant.parse("2025-03-05T10:00:00Z")

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, requestDate, "nearest")

        // Then
        assertThat(result).isEmpty()
        log.info("Nearest mode: No fixtures found (expected)")
    }

    @Test
    fun `invalid 모드 - 빈 리스트 반환`() {
        // Given
        val targetDate = Instant.parse("2025-03-05T10:00:00Z")
        val fixture = createFixture("f1", targetDate, "Not Started")
        fixtureCoreRepository.save(fixture)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, targetDate, "invalid_mode")

        // Then
        assertThat(result).isEmpty()
        log.info("Invalid mode: Returned empty list (expected)")
    }

    @Test
    fun `DTO 매핑 검증 - 모든 필드가 올바르게 매핑되어야 한다`() {
        // Given
        val targetDate = Instant.parse("2025-03-05T14:30:00Z")
        val fixture =
            FixtureCore(
                uid = "test_fixture",
                kickoff = targetDate,
                status = "First Half",
                statusShort = FixtureStatusShort.FIRST_HALF,
                elapsedMin = 30,
                league = testLeague,
                homeTeam = homeTeam,
                awayTeam = awayTeam,
                goalsHome = 2,
                goalsAway = 1,
                finished = false,
                available = true,
                autoGenerated = false,
            )

        fixtureCoreRepository.save(fixture)
        em.flush()
        em.clear()

        // When
        val result = adminFixtureQueryWebService.findFixturesByLeague(testLeague.id!!, targetDate, "exact")

        // Then
        assertThat(result).hasSize(1)
        val dto = result[0]
        assertThat(dto.uid).isEqualTo("test_fixture")
        assertThat(dto.kickoffAt).isEqualTo(targetDate.toString())
        assertThat(dto.homeTeam).isEqualTo("Home Team")
        assertThat(dto.awayTeam).isEqualTo("Away Team")
        assertThat(dto.status).isEqualTo("First Half")
        assertThat(dto.available).isTrue()

        log.info("DTO mapping verified: $dto")
    }

    private fun createFixture(
        uid: String,
        kickoff: Instant,
        status: String,
    ): FixtureCore =
        FixtureCore(
            uid = uid,
            kickoff = kickoff,
            status = status,
            statusShort = FixtureStatusShort.NS,
            league = testLeague,
            homeTeam = homeTeam,
            awayTeam = awayTeam,
            goalsHome = 0,
            goalsAway = 0,
            finished = false,
            available = true,
            autoGenerated = false,
        )
}
