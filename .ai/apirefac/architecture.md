# Footballay API 리팩토링 아키텍처 (kotlin-refac 최신)

## 핵심 개요

-   공통 식별과 외부 종속 제거를 위해 Core-API 분리.
-   백본(backbone)은 라이브 경기 데이터의 정규화/지탱 구조, 라이브(live)는 경기 단위 실시간 데이터.
-   외부 Provider(ApiSports 등)별 API 엔티티는 Core와 1:1 또는 N:1로 연결되며, Provider의 불완전/변동 특성을 흡수.

## 계층/모듈 개념

-   Core: 리그/팀/선수/경기 일정에 대한 플랫폼 공통 데이터. 외부 의존 없음. uid 기반 외부노출 ID 유지.
-   API(ApiSports 등): Provider 별 원천 데이터. Core와 약결합. preventUpdate 등 수동 보정 플래그 제공.
-   Backbone: 라이브 경기 데이터를 지탱하는 구조(경기별 팀/선수/통계/XG/이벤트 등), Provider 특화 모델을 사용.
-   Live: 실시간 수집 중 발생하는 데이터 스트림 의미. 코드 상 naming은 match로 구현된 곳이 있어 용어 일원화 필요.

## 엔티티와 테이블 맵

-   Core
    -   `LeagueCore` → `refac_leagues`
    -   `TeamCore` → `refac_teams`
    -   `PlayerCore` → `refac_players`
    -   `FixtureCore` → `refac_fixtures`
    -   Rel: `LeagueTeamCore` → `refac_league_team` (uk: league_core_id, team_core_id)
    -   Rel: `TeamPlayerCore` → `refac_team_player`
-   ApiSports (Provider)
    -   `LeagueApiSports` → `refac_league_apisports`
        -   `LeagueApiSportsSeason` → `refac_league_apisports_seasons` (embed: `LeagueApiSportsCoverage`)
    -   `TeamApiSports` → `refac_team_apisports` (ref: `VenueApiSports` → `refac_venue_apisports`)
    -   `PlayerApiSports` → `refac_player_apisports`
    -   `FixtureApiSports` → `refac_fixtures_apisports` (embed: `ApiSportsStatus`, `ApiSportsScore`)
-   ApiSports Live/Backbone (경기 단위)
    -   `ApiSportsMatchTeam` → `refac_apisports_match_team`
    -   `ApiSportsMatchPlayer` → `refac_apisports_match_player`
    -   `ApiSportsMatchTeamStatistics` → `refac_apisports_match_team_stats`
    -   `ApiSportsMatchTeamXG` → `refac_apisports_match_team_xg`
    -   `ApiSportsMatchPlayerStatistics` → `refac_apisports_match_player_stats`
    -   `ApiSportsMatchEvent` → `refac_apisports_match_event`

## 대표 엔티티 스냅샷

```12:40:src/main/kotlin/com/footballay/core/infra/persistence/core/entity/FixtureCore.kt
@Entity
@Table(name = "refac_fixtures")
data class FixtureCore(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,
    @Column(name = "uid", unique = true, nullable = false, updatable = false)
    var uid: String,
    var kickoff: OffsetDateTime?,
    var timestamp: Long?,
    var status: String,
    @Enumerated(EnumType.STRING)
    var statusShort: FixtureStatusShort,
    var elapsedMin: Int? = null,
    @ManyToOne(fetch = FetchType.LAZY) var league: LeagueCore,
    @ManyToOne(fetch = FetchType.LAZY, optional = true) var homeTeam: TeamCore?,
    @ManyToOne(fetch = FetchType.LAZY, optional = true) var awayTeam: TeamCore?,
    var goalsHome: Int? = null,
    var goalsAway: Int? = null,
    @Column(nullable = false) var finished: Boolean = false,
    @Column(nullable = false) var available: Boolean = false,
    @Column(nullable = false) var autoGenerated: Boolean = true
)
```

```20:40:src/main/kotlin/com/footballay/core/infra/persistence/apisports/entity/FixtureApiSports.kt
@Entity
@Table(name = "refac_fixtures_apisports", indexes = [Index(name = "idx_fixture_apisports_core_id", columnList = "fixture_core_id")])
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
data class FixtureApiSports(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,
    @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name = "fixture_core_id", referencedColumnName = "id")
    var core: FixtureCore? = null,
    @Column(name = "api_id", unique = true, nullable = false)
    var apiId: Long,
    var referee: String? = null,
    var timezone: String? = null,
    var date: OffsetDateTime? = null,
    var timestamp: Long? = null,
    var round: String? = null,
    var preventUpdate: Boolean = false,
    @Embedded var status: ApiSportsStatus? = null,
    @Embedded var score: ApiSportsScore? = null,
    @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "venue_id") var venue: VenueApiSports? = null,
    @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "season_id") var season: LeagueApiSportsSeason?,
    @OneToOne(cascade = [CascadeType.ALL], fetch = FetchType.LAZY) @JoinColumn(name = "home_team_id") var homeTeam: ApiSportsMatchTeam? = null,
    @OneToOne(cascade = [CascadeType.ALL], fetch = FetchType.LAZY) @JoinColumn(name = "away_team_id") var awayTeam: ApiSportsMatchTeam? = null,
    @OneToMany(mappedBy = "fixtureApi", cascade = [CascadeType.ALL], fetch = FetchType.LAZY) var events: MutableList<ApiSportsMatchEvent> = mutableListOf(),
)
```

```12:31:src/main/kotlin/com/footballay/core/infra/persistence/core/entity/LeagueCore.kt
@Entity
@Table(name = "refac_leagues")
data class LeagueCore(
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long? = null,
  @Column(name = "uid", unique = true, nullable = false) var uid: String,
  @Column(nullable = false) var name: String,
  @Column(nullable = false) var available: Boolean = false,
  @Column(nullable = false) var autoGenerated: Boolean = true,
  @OneToMany(mappedBy = "league", cascade = [CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE], orphanRemoval = true)
  var leagueTeams: MutableSet<LeagueTeamCore> = mutableSetOf()
)
```

## Core-API 분리 선택 이유

-   외부 API의 불완전성/변동성 격리: apiId null/변경, 데이터 누락, 캐싱 문제를 `ApiSports*` 레이어에서 흡수.
-   도메인 안정성 보장: Core는 외부 의존 없이 식별자(uid)와 최소 필드만 유지, 장기 호환성 확보.
-   수동 보정 허용: `preventUpdate` 와 같은 플래그로 운영 중 수동 보정치를 보존.
-   다중 Provider 확장: 동일 Core에 다수 Provider 엔티티를 연결해 소스 다변화 가능.

## Backbone/Live 구조 선택 이유

-   경기 단위 모델 분리: 라인업/선수/팀 통계/XG/이벤트 등은 경기 순간 스냅샷이므로 별도 엔티티로 기록.
-   조회/추적 최적화: `match_player_uid`, XG 시간축(unique: match_team_statistics_id, elapsed_time) 등 자연키/인덱스로 빠른 질의.
-   변경 내성: 경기 중 변동(교체, VAR, 득점정정)을 이벤트 스트림으로 안전하게 반영.

## 용어 일관성 가이드

-   코드 상 `match` 접두가 붙은 엔티티는 “라이브 경기 단위”를 의미. 문서/게시/명세에서는 “Live”로 통일.
-   향후 클래스/패키지명 리팩토링 시: `ApiSportsMatch*` → `ApiSportsLive*`로 변경 검토.

## 동기화(Backbone ↔ Core) 개요

-   ApiSports Syncer: Provider에서 수집 → ApiSports 엔티티 업데이트 → 필요 시 Core와 매핑/생성(`autoGenerated=true`).
-   예: 팀 동기화 시 `TeamApiSports` 생성/업데이트 후, `TeamCore` 존재 확인 없으면 uid 발급해 생성.

## 운영 체크리스트

-   Core의 uid는 외부 공개 ID로 강제 unique.
-   Core에 Provider 전용 필드(apiId 등)를 두지 않음.
-   ApiSports 측 수동 보정 필요 시 `preventUpdate=true` 활용.
-   Live 데이터의 자연 키/인덱스 유지: `match_player_uid`, XG unique 복합키.

## 아키텍처 점검 (현 코드 기준)

-   **라이브 동기화 파이프라인 분리 수준 양호**: Fetch → Extract → Pre-sync Players → DTO fan-out → Persist 흐름이 명확합니다.

```40:69:src/main/kotlin/com/footballay/core/infra/apisports/match/ApiSportsMatchSyncer.kt
@Component
class ApiSportsMatchSyncer(
    private val fetcher: ApiSportsV3Fetcher,
    private val playerExtractor: FixturePlayerExtractor,
    private val playerSyncExecutor: PlayerSyncExecutor,
    private val matchSyncService: MatchApiSportsSyncer,
    private val fixtureQueryService: FixtureApiSportsQueryService,
) : MatchDataSyncer {
    override fun syncMatchData(uid: String): ActionAfterMatchSync {
        val response = fetchLiveResponse(uid)
        val playerSyncDtoList = playerExtractor.extractAndSyncPlayers(response)
        playerSyncExecutor.syncPlayers(playerSyncDtoList)
        val fullMatchSyncDto = FullMatchSyncDto.Companion.of(response)
        return matchSyncService.syncFixtureMatchEntities(fullMatchSyncDto)
    }
}
```

-   **DTO 추출과 실제 저장의 분리**: 엔티티 저장 전 DTO 계층으로 분해 후 `MatchEntitySyncService`에 위임하는 구조가 유지보수에 유리합니다.

```47:75:src/main/kotlin/com/footballay/core/infra/apisports/match/sync/MatchApiSportsSyncerImpl.kt
@Service
class MatchApiSportsSyncerImpl(
    private val baseDtoHelper: MatchBaseDtoExtractor,
    private val lineupDtoHelper: MatchLineupDtoExtractor,
    private val eventDtoHelper: MatchEventDtoExtractor,
    private val teamStatHelper: MatchTeamStatDtoExtractor,
    private val playerStatHelper: MatchPlayerStatDtoExtractor,
    private val matchEntitySyncService: MatchEntitySyncService
) : MatchApiSportsSyncer {
    override fun syncFixtureMatchEntities(dto: FullMatchSyncDto): ActionAfterMatchSync {
        val context = MatchPlayerContext()
        val baseDto = baseDtoHelper.extractBaseMatch(dto)
        val lineupDto = lineupDtoHelper.extractLineup(dto, context)
        val eventDto = eventDtoHelper.extractEvents(dto, context)
        val teamStatDto = teamStatHelper.extractTeamStats(dto)
        val playerStatDto = playerStatHelper.extractPlayerStats(dto, context)
        return matchEntitySyncService.syncMatchEntities(
            fixtureApiId = dto.fixture.id,
            baseDto = baseDto,
            lineupDto = lineupDto,
            eventDto = eventDto,
            teamStatDto = teamStatDto,
            playerStatDto = playerStatDto,
            playerContext = context
        )
    }
}
```

-   **Persist 단계 진행상황 명시(좋음)**: 단계/완료 여부가 주석으로 관리되어 향후 마무리 포인트가 분명합니다.

```41:62:src/main/kotlin/com/footballay/core/infra/apisports/match/sync/persist/MatchEntitySyncServiceImpl.kt
@Service
class MatchEntitySyncServiceImpl(
    private val matchDataLoader: MatchDataLoader,
    private val baseMatchEntitySyncer: BaseMatchEntitySyncer,
    private val matchPlayerManager: MatchPlayerManager,
    private val matchEventManager: MatchEventManager,
    private val playerStatsManager: PlayerStatsManager
) : MatchEntitySyncService {
    @Transactional
    override fun syncMatchEntities(...): MatchEntitySyncResult {
        // Phase 1~5 완료, 6~7 TODO 상태
    }
}
```

-   **Core 스냅샷 최소 필드 전략은 이미 일부 반영**: `PlayerCore`, `TeamCore`, `LeagueCore`, `FixtureCore`에 공통 필드가 존재해 읽기 기본 경로 단순화의 토대가 있음.

## Canonical Model / Resolver 설계 제안

-   **목표**: Core 개발자는 “uid만 전달 → Canonical Model 반환”만 사용. Provider/Failover/병합/캐시는 Resolver 내부에 캡슐화.

-   **Canonical Model (예시 스케치)**

```kotlin
// 제안: 읽기 전용 모델. 공통 필드는 명시 필드로, 확장은 타입 안전 Feature로 합성
data class PlayerModel(
    val uid: String,
    val name: String,
    val firstname: String?,
    val lastname: String?,
    val age: Int?,
    val nationality: String?,
    val position: String?,
    val features: Set<PlayerFeature> = emptySet(),
)
sealed interface PlayerFeature {
    data class BirthInfo(val city: String?, val nation: String?) : PlayerFeature
    data class Physical(val height: String?, val weight: String?) : PlayerFeature
    data class DistanceCovered(val meters: Int?) : PlayerFeature
}
```

-   **Resolver 추상화**

```kotlin
interface PlayerModelResolver {
    fun resolveByUid(uid: String): PlayerModel
}
```

-   구현은 ProviderAdapter 체인 + 필드별 병합전략 + 캐시를 내부에 포함.
-   “융합 데이터”는 읽기 전용으로 표기(예: `source=FUSED`)하여 쓰기 경로 혼선 방지.

-   **Provider Adapter + Capability**

```kotlin
interface PlayerProviderAdapter {
    val providerId: String
    val capabilities: Set<PlayerCapability>
    fun fetchByUid(uid: String): PlayerModel // 제공 가능한 필드/feature만 채워서 반환
}
enum class PlayerCapability { BASIC, BIRTH_INFO, PHYSICAL, DISTANCE_COVERED }
```

-   **필드 병합전략/선택정책**
-   필드별 우선순위 테이블(설정화 가능) + Circuit breaker/TTL 캐시.
-   예: name=ApiSports>Sportmonks, birthNation=KLeague>ApiSports>Sportmonks, distanceCovered=Sportmonks only

-   **쓰기 경로 원칙**
-   기본: Provider 명시(@sync 계층처럼).
-   미명시 허용 시: Model에 `sourceMeta`(provider origin/field lineage) 포함해 경고/차단 정책 적용. `source=FUSED`는 쓰기 금지.

## 현 구조와의 정합성 판단

-   멀티 Provider·Failover를 지향하는 Core-Api 분리의 방향은 적절.
-   Core에 공통 필드 스냅샷이 있어 읽기 기본 경로 단순화 가능(좋음). 향후 Canonical Resolver를 추가하면 Core 개발자 경험 개선됨.
-   라이브 파이프라인은 추출/저장을 계층 분리하여 확장·테스트 용이(좋음). 명칭만 Live로 통일 필요.

## 권장 로드맵(단계별)

-   1. ProviderSelectionPolicy/FieldMerge/Capability 컴포넌트 구현(도메인 한 지점에 집중).
-   2. Player/Team/League/Fixture Canonical Model 정의 + ApiSports Adapter 1종 구현.
-   3. Resolver(Service) 도입: `resolveByUid(uid)` 제공. 조회 서비스 일부를 Resolver 경유로 전환.
-   4. 캐시(읽기 전용) 추가: stale-while-revalidate 가능.
-   5. 필요 시 Sportmonks Adapter 추가 → 정책에 연결. Live 명칭 통일 리팩토링.
-   6. 쓰기 경로는 현 `@sync` 계층 유지. 추후 비명시 쓰기 요구 시 `sourceMeta`로 제한적 허용.

## 리스크와 완화

-   복잡도 증가: 정책/병합 논리가 퍼지지 않도록 Resolver 내부로 집중.
-   타입 안전성: 확장 필드는 sealed feature로만 허용(Map 금지).
-   성능: 캐시와 스냅샷(Core) 우선 사용. Provider 호출은 보강시에만.

## Core-API / Backbone 구조 총정리 (DB 스키마 관점 + 타당성)

-   **분리 원칙**

    -   Core: 공통 스냅샷·식별 레이어(`refac_*` 핵심 테이블). 외부 의존 제거, uid 중심. 읽기 기본 경로의 안정성·성능 확보.
    -   API: Provider 원천 데이터(`refac_*_apisports`, 시즌/커버리지/상태/스코어 등 세부 필드 포함). preventUpdate 등 운영 보정 허용.
    -   Backbone(Live/Match): 경기 단위 스냅샷 구조(`refac_apisports_match_*`). 라인업/이벤트/통계/XG 등 시간·순서 보존.

-   **DB 스키마 요지**

    -   Core 테이블: `refac_leagues`, `refac_teams`, `refac_players`, `refac_fixtures`, 관계(`refac_league_team`, `refac_team_player`).
    -   API 테이블: `refac_league_apisports`(+`_seasons`), `refac_team_apisports`, `refac_player_apisports`, `refac_fixtures_apisports`, `refac_venue_apisports`.
    -   Live 테이블: `refac_apisports_match_team|player|team_stats|player_stats|team_xg|event`.

-   **타당성 평가**
    -   멀티 Provider/Failover 대비 및 OCP 달성 관점에서 적절.
    -   읽기 성능/안정성: Core 스냅샷으로 기본 경로 단순화(이미 일부 구현).
    -   변경 내성: Backbone이 경기 시점 스냅샷을 정규화해 일관성 유지.
    -   주의: Live 명칭 일관화, 병합정책 중앙화, 과도한 양방향 의존 방지 필요.

## Provider-aware 개발자 가이드 (책임과 집중 포인트)

-   **책임 범위**

    -   Provider Fetch → DTO 변환(필요 시) → API 엔티티 저장/업데이트 → Core 스냅샷 병합 갱신.
    -   Live 동기화 파이프라인 유지: Fetch → Extract → Pre-sync Players → DTO fan-out → Persist.

-   **집중 구현 포인트**

    -   Adapter/Fetcher: API 호출 안정화(리트라이, 타임아웃, 서킷브레이커), 응답 스키마 변화 흡수.
    -   Entity Mapping: API → `refac_*_apisports`(또는 Live) 정확 매핑, `preventUpdate` 준수.
    -   병합정책: 필드별 우선순위/캡빌리티 반영하여 Core 스냅샷 갱신(일관 규칙, 단일 컴포넌트 유지).
    -   동기화 순서: 선수 사전 동기화 → 라인업/이벤트/통계 순서 보장, 자연키/유니크 제약 준수.

-   **현재 코드 적합성**

    -   `ApiSportsMatchSyncer` → `MatchApiSportsSyncerImpl` → `MatchEntitySyncServiceImpl` 파이프라인 분리 양호.
    -   Persist 단계 진행현황 명확(Phase 1~5 완료, 6~7 TODO). 마무리만 하면 일관된 저장 파이프라인 완성.

-   **UID 질의 응답 전략(Provider 미지식자 배려)**
    -   Canonical Resolver를 통해 `resolveByUid(uid)`로 모델 제공.
    -   기본은 Core 스냅샷 값 사용, 부족 필드는 Provider Adapter 체인으로 보강 후 병합.
    -   읽기 캐시 적용(stale-while-revalidate)로 안정성/성능 확보.

## Provider-agnostic 개발자 가이드 (단순 사용 패턴)

-   **사용 방법(목표 API)**

    -   Service: `FixtureModelResolver.resolveByUid(uid)` → `FixtureModel` 반환.
    -   Controller/Service 레이어는 엔티티/JPA/Provider를 몰라도 됨. 모델만 사용.

-   **모델 보장(예측성)**

    -   공통 필드: 항상 존재(예: PlayerModel.name, FixtureModel.statusShort 등). Not-null 계약 문서화.
    -   선택 필드: nullable로 명확 표시, 확장은 sealed feature로 타입 안전 제공(Map 금지).
    -   `sourceMeta`: 융합(FUSED)/단일 Provider 표기. FUSED는 읽기 전용임을 명시.

-   **현재 스키마와의 접합성**

    -   Core 스냅샷 필드가 이미 다수 존재 → Canonical Model 기본값 충족 용이.
    -   확장/Live 값은 Adapter(feature)로 보강 가능 → 분리된 Live 스키마와 충돌 없음.

-   **추상화 계층 최소화 요령**
    -   Resolver 내부에만 Provider 선택/병합 로직 집중. 외부에는 단일 메서드만 노출.
    -   모델 초안 문서화(필수/선택/feature) → 컨트롤러/프론트 예측 가능성 확보.
